\documentclass[9pt]{beamer}
\usetheme{default}
\setbeamercovered{invisible}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{
    \flushright{\hfill \insertframenumber{}/\inserttotalframenumber}
}

\usepackage{listings}

% User-defined colors.
\definecolor{DarkGreen}{rgb}{0, .5, 0}
\definecolor{DarkBlue}{rgb}{0, 0, .5}
\definecolor{DarkRed}{rgb}{.5, 0, 0}
\definecolor{LightGray}{rgb}{.95, .95, .95}
\definecolor{White}{rgb}{1.0,1.0,1.0}
\definecolor{darkblue}{rgb}{0,0,0.9}
\definecolor{darkred}{rgb}{0.8,0,0}
\definecolor{darkgreen}{rgb}{0.0,0.85,0}

% Settings for listing class.
\lstset{
  language=C++,                        % The default language
  basicstyle=\small\ttfamily,          % The basic style
  backgroundcolor=\color{White},       % Set listing background
  keywordstyle=\color{DarkBlue}\bfseries, % Set keyword style
  commentstyle=\color{DarkGreen}\itshape, % Set comment style
  stringstyle=\color{DarkRed}, % Set string constant style
  extendedchars=true % Allow extended characters
  breaklines=true,
  basewidth={0.5em,0.4em},
  fontadjust=true,
  linewidth=\textwidth,
  breakatwhitespace=true,
  showstringspaces=false,
  lineskip=0ex, %  frame=single
}

\begin{document}
    \title{Lab 04} \subtitle{Profiling, debugging and class templates}
    \author{Paolo Joseph Baioni}
    \date{\today}

\begin{frame}[plain, noframenumbering]
    \maketitle
\end{frame}

\begin{frame}{Recalls}{Introduction to exercise 1}
\begin{itemize}
\item The implemented matrix class is organized as
      \textbf{column-major}, \textit{i.e.}
      $A(i, j) = $ \lstinline{data[i + j * rows()]}, 
      conversion from 1d to 2d indexing is performed by the utility
      method \lstinline{sub2ind}.\\[3mm]
\item Access to elements is implemented both in \texttt{const} and non-\texttt{const} versions, by overloading \lstinline{operator()}. \\[3mm]
\item Data is private, \textit{getter methods} expose what is needed to the user, both \texttt{const} and non-\texttt{const} versions are provided. \\[3mm]
\item Naive implementation of matrix-matrix multiplication is slow because it has low \textit{data locality}, simply transposing the left matrix factor improves performance significantly\footnote{See \textit{M. Kowarschik, C. Wei√ü. (2002). Lecture Notes in Computer Science. 213-232. DOI: 10.1007/3-540-36574-5\_10} for further details.}.\\[3mm]
\item The \lstinline{\#include <ctime>} header provides timing utilities, \lstinline{tic()} and \lstinline{toc(x)} macros start and stop the timer.
\end{itemize}
\end{frame}

\begin{frame}{Follow-up of Lab 3}{Exercise 1.3}
\begin{itemize}
{\color{gray}\item Include the {\tt Eigen/Dense} header.
\item Use the {\tt Eigen::Map} template class to wrap the matrix data and interpret it as {\tt Eigen::MatrixXd}.}
\item Compare the execution speed with respect to the previous implementations for varying matrix size, such as 
{\ttfamily msize=500} and {\ttfamily msize=5000}.
\end{itemize}
\end{frame}

\begin{frame}{Profiling and memory cheking}{Exercise 1.4}
Going back to Ex. 1.2, perform the subsequent analysis:
\begin{itemize}
\item coverage ({\ttfamily lcov})
\item memcheck ({\ttfamily valgrind})
\item profile ({\ttfamily valgrind, kcachegrind})
\end{itemize}
\end{frame}

\begin{frame}{Debugging}{Exercise 2}
The program \texttt{integer-list} in the directory \texttt{02-bug} has:

\begin{itemize}
    \item a compile error;
    \item a run-time error;
    \item a memory leak;
    \item a potential memory leak that is not captured by the \texttt{main}.
\end{itemize}
\vspace{0.5cm}
Find all the issues and fix them. \\[3mm]

Get help by using \texttt{gdb} and \texttt{valgrind}.\\[3mm]
\end{frame}

\begin{frame}[fragile]{Class templates}{Finite differences}
Implement a \texttt{C++} template class to evaluate derivatives of any order of a given function (callable object) at a given point using recursive backward/forward first-order finite difference formulas.
\end{frame}

\begin{frame}{Class templates}{Sparse matrix introduction}
\begin{itemize}
\item A $N \times N$ sparse matrix is a matrix whose number of non-zero elements $N_\mathrm{nz}$ is $O(N)$. \\[3mm]
\item The average number $m$ of non-zero elements per row (or column)
is constant w.r.to the matrix size. \\[3mm]
\item If the majority of matrix entries is $0$, {\it i.e.} if $m \ll N$ it is convenient to store only the non-zero elements.\\[3mm]
\item The matrix-vector product (which is the basic ingredient of Krylov solvers) costs $O(N)$ rather than $O(N^{2})$.\\[3mm]
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Class templates}{Sparse matrix formats}
Some (slightly revisited) classical data structures for sparse matrices

\begin{equation*}
A = 
\begin{bmatrix}
4  & -1 & 0  & 0\\
-1 &  4 & -1 & 0\\
0  & -1 &  4 & -1\\
0  &  0 &  -1& 4
\end{bmatrix}
\end{equation*}

\begin{itemize}
\item [COO] (coordinates) or AIJ: \tiny
\begin{lstlisting}
std::vector<double>       A{4, -1, -1, ...};
std::vector<unsigned int> I{0,  0,  1, ...};
std::vector<unsigned int> J{0,  1,  0, ...};
\end{lstlisting} \normalsize
\item [triplet] vector:\tiny
\begin{lstlisting}
std::vector<std::tuple<unsigned int, unsigned int, double>> 
  t{{0, 0, 4}, {0, 1, -1}, {1, 0, -1}, ...};
\end{lstlisting} \normalsize
\item [CSR] (Compressed Sparse Row) or CRS (Compr. Row Storage) or Yale:\tiny
\begin{lstlisting}
std::vector<double>       val{4, -1, -1, 4, -1, -1, 4, -1, -1, 4};
std::vector<unsigned int> col_idx{0, 1, 0, 1, 2, 1, 2, 3, 2, 3};
std::vector<unsigned int> row_ptr{0, 2, 5, 8, 10}; // n_rows + 1.
\end{lstlisting} 
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Class templates}{Sparse matrix typical operations} 
\begin{itemize}
\item Insertion: \\
\lstinline|A[i][j] = x;|
\item Deletion: \\
\lstinline|A[i].erase(j);| or \lstinline|A.erase(i, j);|
\item Random access: \\
\lstinline|x = A[i][j]; A[i][j] += y;|
\item Sequential traversing:
\small\begin{lstlisting}
for (row : A)
  {
    for (column : row)
      std::cout << column.value << " ";
    std::cout << std::endl;
  }
\end{lstlisting}\normalsize
\item Matrix-vector multiplication:\\
\lstinline|std::vector<double> y = A * x;|
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Class templates}{Inheriting from STL containers}
The \texttt{C++} standard is very permissive for the implementation of new containers, but:
\begin{itemize}
\item STL containers have non-virtual destructors!
\item \href{http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\#Rc-dtor-virtual}{C.35: A base class destructor should be either public and virtual, or protected and non-virtual.}
\small\begin{lstlisting}
class Base {
public:
  ~Base { do_something(); }; // Non-virtual.
}

class Derived : public Base {
public:
  MyComplexType member;
  ~Derived { member.clear(); ... }
}

Base *var = new Derived;
delete var; // Calls var::~Base() but not var::~Derived()!
\end{lstlisting}\normalsize
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Class templates}{Sparse matrix exercise}
\begin{itemize}
\item Implement a \texttt{C++} class to represent a sparse matrix inheriting from suitable STL containers.
\item Simplify random access, allocation, entry increment, sequential traversing.
\item (Optional) Refactor the code: instead of inheriting, make the actual STL container a private class member. Which operators should be added for the code to compile?
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Class templates}{Sparse matrix exercise}
Implement the following methods:
\begin{lstlisting}[basicstyle=\footnotesize]
/// Convert row-oriented sparse matrix to AIJ format.
void
aij(std::vector<double> &      a,
    std::vector<unsigned int> &i,
    std::vector<unsigned int> &j);

/// Convert row-oriented sparse matrix to CSR format.
void csr(std::vector<double> &      a,
         std::vector<unsigned int> &col_ind,
         std::vector<unsigned int> &row_ptr);

/// Stream operator.
friend std::ostream &
operator<<(std::ostream &stream,Class templates}{Sparse matrix exercise}
           sparse_matrix &M);

/// Sparse matrix increment.
void sparse_matrix::operator+=(sparse_matrix &other);

/// Compute matrix-vector product.
friend std::vector<double>
operator*(sparse_matrix &M,
          const std::vector<double> &x);
\end{lstlisting}
\end{frame}

\end{document}
