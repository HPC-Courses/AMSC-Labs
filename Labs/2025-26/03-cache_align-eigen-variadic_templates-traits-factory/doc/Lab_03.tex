\documentclass[10pt]{beamer}
\usetheme{default}
\setbeamercovered{invisible}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{
    \flushright{\hfill \insertframenumber{}/\inserttotalframenumber}
}

\usepackage{listings}

% User-defined colors.
\definecolor{DarkGreen}{rgb}{0, .5, 0}
\definecolor{DarkBlue}{rgb}{0, 0, .5}
\definecolor{DarkRed}{rgb}{.5, 0, 0}
\definecolor{LightGray}{rgb}{.95, .95, .95}
\definecolor{White}{rgb}{1.0,1.0,1.0}
\definecolor{darkblue}{rgb}{0,0,0.9}
\definecolor{darkred}{rgb}{0.8,0,0}
\definecolor{darkgreen}{rgb}{0.0,0.85,0}

% Settings for listing class.
\lstset{
  language=C++,                        % The default language
  basicstyle=\small\ttfamily,          % The basic style
  backgroundcolor=\color{White},       % Set listing background
  keywordstyle=\color{DarkBlue}\bfseries, % Set keyword style
  commentstyle=\color{DarkGreen}\itshape, % Set comment style
  stringstyle=\color{DarkRed}, % Set string constant style
  extendedchars=true % Allow extended characters
  breaklines=true,
  basewidth={0.5em,0.4em},
  fontadjust=true,
  linewidth=\textwidth,
  breakatwhitespace=true,
  showstringspaces=false,
  lineskip=0ex, %  frame=single
}

\begin{document}
    \title{Lab 03} \subtitle{Cache alignement - Eigen - Factories, variadic templates and traits}
    \author{Paolo Joseph Baioni}
    \date{\today}

\begin{frame}[plain, noframenumbering]
    \maketitle
\end{frame}

\begin{frame}{Cache alignement}{Introduction to exercise 1}
\begin{itemize}
\item The implemented matrix class is organized as
      \textbf{column-major}, \textit{i.e.}
      $A(i, j) = $ \lstinline{data[i + j * rows()]}, 
      conversion from 1d to 2d indexing is performed by the utility
      method \lstinline{sub2ind}.\\[3mm]
\item Access to elements is implemented both in \texttt{const} and non-\texttt{const} versions, by overloading \lstinline{operator()}. \\[3mm]
\item Data is private, \textit{getter methods} expose what is needed to the user, both \texttt{const} and non-\texttt{const} versions are provided. \\[3mm]
\item Naive implementation of matrix-matrix multiplication is slow because it has low \textit{data locality}, simply transposing the left matrix factor improves performance significantly\footnote{See \textit{M. Kowarschik, C. Wei√ü. (2002). Lecture Notes in Computer Science. 213-232. DOI: 10.1007/3-540-36574-5\_10} for further details.}.\\[3mm]
\item The \lstinline{\#include <ctime>} header provides timing utilities, \lstinline{tic()} and \lstinline{toc(x)} macros start and stop the timer.
\end{itemize}
\end{frame}

\begin{frame}{Cache alignement}{Exercise 1.1}

Starting from the provided implementation of the class for dense matrices (and column vectors represented as 1-column matrices) based on \lstinline{std::vector}, implement the following methods:
\begin{itemize}
\item transpose: $A = A^{T}$.
\item \lstinline{operator*}: matrix-matrix and matrix-vector multiplication.
\end{itemize}
\end{frame}

\begin{frame}{Cache alignement}{Exercise 1.2}
\begin{itemize}
\item Transpose the first factor in matrix multiplication before performing the product.
\item Compare the execution speed with respect to the previous implementation.
\end{itemize}
\end{frame}

\begin{frame}{Cache alignement}{Exercise 1.2 - Details}
\begin{figure}
    \centering
    \only<1>{\includegraphics[width=\textwidth]{images/memory_layout.png}}
    \only<2>{\includegraphics[width=\textwidth]{images/access_patterns.png}}
    \only<3>{\includegraphics[width=\textwidth]{images/loop_tiling.png}}
    \caption{\alt<1>{Typical memory layout of a computer.}{Example with a row-major matrix.}}
\end{figure}
\end{frame}

\begin{frame}{Eigen}{Exercise 1.3}
\begin{itemize}
{\color{black}\item Include the {\tt Eigen/Dense} header.
\item Use the {\tt Eigen::Map} template class to wrap the matrix data and interpret it as {\tt Eigen::MatrixXd}.}
{\item Compare the execution speed with respect to the previous implementations.}
\end{itemize}
\end{frame}

\begin{frame}{Factories, variadic templates and traits}{Exercise 2 - Newton solver}
	This example (an extended version of \texttt{Examples/src/NewtonSolver}) is about a set of tools that implement generic Newton or quasi-Newton methods to determine the zero of scalar non-linear equations, as well as vector systems using the \texttt{Eigen} library.
	
	The code structure is the following:
	\begin{itemize}
		\item \texttt{NewtonTraits} contains the definition of the types used by the main classes, to guarantee uniformity.
		\item \texttt{JacobianBase} is a base class which implements the action of a \textit{quasi-Jacobian}: the user may choose among \texttt{FullJacobian} where the actual Jacobian must be specified by the user, and \texttt{DiscreteJacobian}, that approximates the Jacobian via finite differences.
		\item \texttt{JacobianFactory} instantiates a concrete derived class of \texttt{JacobianBase} family on the fly.
		\item \texttt{Newton} applies the Newton method, given the non-linear system and a \texttt{JacobianBase}.
		\item \texttt{NewtonOptions} and \texttt{NewtonResults} bind the input options and the output results.
	\end{itemize}
\end{frame}

\begin{frame}{Factories, variadic templates and traits}{Exercise 2 - Newton solver}
	Consider the problem
	\[
	\mathbf{f}(x, y) =
	\begin{bmatrix}
		(x-1)^2 + 0.1(y - 5)^2 \\
		1.5 -x - 0.1y
	\end{bmatrix}
	=
	\mathbf{0}.
	\]
	
	Starting from the provided solution sketch:
	\begin{enumerate}
		\item Implement the \texttt{NewtonTraits} class defining common types for homogeneity.
		\item Implement the \texttt{FullJacobian} class (inheriting from \texttt{JacobianBase}) which, provided the full Jacobian matrix, solves the linear system using a direct solver with \(LU\) factorization.
		\item \texttt{DiscreteJacobian} (inheriting from \texttt{JacobianBase}) which approximates the system Jacobian using finite differences and solves the linear system using a direct solver with \(LU\) factorization.
		\item Implement a \texttt{JacobianFactory} method, returning an istance of \texttt{FullJacobian} or \texttt{DiscreteJacobian} depending on a parameter chosen by the user.
		\item Solve the problem above using both the full and the discrete approach.
	\end{enumerate}
\end{frame}

\end{document}
